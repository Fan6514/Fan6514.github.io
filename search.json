[{"title":"Hexo使用方法","url":"/2023/01/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nCreate a new article$ hexo new [layout] &lt;title&gt;\n\n","tags":["博客"]},{"title":"【Redis】基础知识","url":"/2023/01/08/%E3%80%90Redis%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":""},{"title":"【数据结构】基本数据结构类型","url":"/2023/01/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/","content":"复杂度分析大O时间复杂度表示法并不是具体表示代码执行的时间，而是表示代码执行时间随数据规模增长的变化趋势，也称为渐进时间复杂度，简称时间复杂度。\n分析时间复杂度方法：\n\n只关注循环执行次数最多的一段代码\n加法法则，总复杂度等于量级最大的那段代码的复杂度\n乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n几种常见的时间复杂度量级：\n\n非多项式量级：$O(2^n)$和$O(n!)$\n时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题，非多项式时间复杂度的算法是非常低效的算法。\nO(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。\n空间复杂度全称就是渐进空间复杂度（asymptotic space complexity)，表示算法的存储空间与数据规模之间的增长关系。\n数组数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。\n数组在内存空间的地址是连续的，支持根据下标随机访问，但在删除或添加元素时，需要移动后面的所有元素。\n线性表（Linear List）就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。\n\n非线性表，比如二叉树、堆、图等，数据之间并不是简单的前后关系。\n\n插入删除操作：如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。如果删除某个元素，我们可以先记录下已经删除的数据，当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。\nC++的vector是容器而不是数组，其底层实现是数组。而二维数组在内存的空间也是连续的。\nJava的二维数组每一行头节点的地址不是连续的：\n\n二分查找二分查找的前提是数组有序，如果数组有重复元素，可以通过控制边界找到最左侧或左右侧的目标元素。二分查找最主要的问题就是需要考虑清楚区间的定义。\nint binarySearch(vector&lt;int&gt; &amp;nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;    while (left &lt;= right) &#123;        int mid = left + (right - left)/2;        if (nums[mid] &lt; target) &#123;            left = target + 1;        &#125;        else if (nums[mid] &gt; target) &#123;            right = target - 1;        &#125;        else &#123;            return mid;        &#125;    &#125;    return -1;&#125;\n\n相关题目：\n\n 35.搜索插入位置\n 34.在排序数组中查找元素的第一个和最后一个位置\n 69.x 的平方根\n 367.有效的完全平方数\n\n双指针双指针法（快慢指针）是通过一个快指针和慢指针在一个循环下完成两个循环的工作。双指针在数组和链表的操作中很常见，例如删除数组中的目标元素：\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slow = 0;        int fast = 0;        while (fast &lt; nums.size()) &#123;            if (val == nums[fast]) &#123;                fast++;            &#125;            else &#123;                nums[slow++] = nums[fast++];            &#125;        &#125;        return slow;    &#125;&#125;;\n\n相关题目：\n\n 26.删除排序数组中的重复项\n 283.移动零\n 844.比较含退格的字符串\n 977.有序数组的平方\n\n滑动窗口滑动窗口，就是不断调节子序列的起始位置和终止位置，从而得到我们想要的结果。实现滑动窗口，要确认以下三点：\n\n窗口内的元素是什么\n窗口的起始位置\n窗口的结束位置\n\n例如，获取数组和长度大于目标值的最小的子数组：\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size()+1;        int sum = 0;        int start = 0;//起始位置        for (int i = 0; i &lt; nums.size(); ++i) &#123;            sum += nums[i];            while (sum &gt;= target) &#123;//窗口内的数组和要大于目标值                len = min(len, i - start + 1);                sum -= nums[start++];//缩小窗口大小            &#125;        &#125;        return len == nums.size()+1 ? 0 : len;    &#125;&#125;;\n\n相关题目：\n\n 904.水果成篮\n 76.最小覆盖子串\n\n链表链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针。\n\n第一个结点叫作头结点，用来记录链表的基地址。最后一个结点叫作尾结点，尾节点的下一个节点指向空地址NULL，表示这是链表中的最后一个结点。\n链表中插入和删除一个数据是非常快速的。只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。\n\n循环链表是一种特殊的单链表。循环链表的尾结点指针是指向链表的头结点。\n循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。\n双向链表每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。\n链表使用技巧技巧一：理解指针或引用的含义\n将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。\n技巧二：警惕指针丢失和内存泄漏\n插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。\n删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。\n技巧三：利用哨兵简化实现难度\n针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。\n哨兵是解决“边界问题”的，不直接参与业务逻辑。引入哨兵结点，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。\n技巧四：重点留意边界条件处理\n检查链表代码是否正确的边界条件有这样几个：\n\n如果链表为空时，代码是否能正常工作？\n如果链表只包含一个结点时，代码是否能正常工作？\n如果链表只包含两个结点时，代码是否能正常工作？\n代码逻辑在处理头结点和尾结点的时候，是否能正常工作？\n\n在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！\n技巧五：举例画图，辅助思考\n链表相关题目：\n\n 单链表反转\n 链表中环的检测\n 两个有序的链表合并\n 删除链表倒数第 n 个结点\n 求链表的中间结点\n\n栈栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。\n特定的数据结构是对特定场景的抽象，数组或链表暴露了太多的操作接口，使用时就比较不可控，更容易出错。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。\n栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。\n栈的应用场景\n栈在函数调用中的应用\n\n操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。\n\n栈在表达式求值中的应用\n\n编译器是通过两个栈来实现表达式求值。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。\n如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。\n例如，3+5*8-6 这个表达式的计算过程：\n\n\n栈在括号匹配中的应用\n\n借助栈来检查表达式中的括号是否匹配。假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。\n用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。\n当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。\n队列先进者先出，这就是典型的“队列”。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。队列跟栈一样，也是一种操作受限的线性表数据结构。\n队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。\n写好队列的关键是确定好队空和队满的判断条件。队列为空的判断条件是 head &#x3D;&#x3D; tail；队列满的判断条件是 (tail+1)%n &#x3D; head。\n\nclass MyCircularQueue &#123;public:    MyCircularQueue(int k) : capacity(k+1), head(0), tail(0) &#123;        items = vector&lt;int&gt;(k+1);    &#125;        bool enQueue(int value) &#123;        if (isFull()) &#123;            return false;        &#125;        items[tail] = value;        tail = (tail+1) % capacity;        return true;    &#125;        bool deQueue() &#123;        if (isEmpty()) &#123;            return false;        &#125;        head = (head+1) % capacity;        return true;    &#125;        int Front() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        return items[head];    &#125;        int Rear() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        return items[(tail-1+capacity)%capacity];    &#125;        bool isEmpty() &#123;        return head == tail;    &#125;        bool isFull() &#123;        return head == (tail+1) % capacity;    &#125;private:    vector&lt;int&gt; items;    int capacity;    int head;    int tail;&#125;;\n\n阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。\n基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。\n\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。\n","tags":["数据结构"]},{"title":"【C/CPP】static静态成员变量和函数详解","url":"/2023/01/08/%E3%80%90C-CPP%E3%80%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/","content":"静态成员变量对象的内存中包含了成员变量，不同对象占用不同内存，使得不同对象的成员变量相互独立。如果希望多个对象之间共享数据，典型使用场景是计数，可以使用静态成员变量来实现多个对象共享数据的目标。\n静态成员变量是一种特殊的成员变量，被关键字static修饰。\nclass Student &#123;public:    Student();    ~Student();private:    static int total_;&#125;;\n\n这段代码声明了一个静态成员变量total_，用来统计学生人数。\nstatic成员变量属于类，不属于某个具体的对象，必须在类声明的外部初始化，具体形式为：\nint Student::total_ = 0;\n\n\n  注意：static成员变量的内存既不是在声明类分配，也不是创建对象分配，而是在类外初始化时分配。没有在类外初始化的static成员变量无法使用。\n  static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。\n\n总结：\n\n一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。\nstatic 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n静态成员变量必须初始化，而且只能在类体外进行。初始化不赋值会被默认初始化为0。\n静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。\n\n\n  全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。\n\n普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。\n静态成员函数编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。\n静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。\n静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。\n静态成员函数与普通成员函数的区别：\n\n普通成员函数有 this 指针，可以访问类中的任意成员；\n静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。\n\n和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用。\n","tags":["cpp"]},{"title":"【C/CPP】const修饰符","url":"/2023/01/09/%E3%80%90C-CPP%E3%80%91const%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"如果不希望某些数据被修改，可以使用const关键字限定。\nconst 成员变量和成员函数const成员变量在初始化时只能通过构造函数的初始化列表。\nconst成员函数可以使用类中的所有成员变量，但是不能修改其值，主要是为了保护数据设置。通常将get函数设置成常成员函数。\n常成员函数在声明和定义的时候需要在函数头部后面加上const关键字。\nclass Student &#123;public:    char *getName() const;private:    char *name_;&#125;;char* Student::getName() const &#123;    return name_;&#125;\n\n注意 const 的位置区分：\n\n函数开头的 const 修饰的是函数的返回值，表示返回值是const类型，不能被修改，例如const char* getName()。\n函数头部结尾的 const 表示常成员函数，只能读取成员变量的值，不能修改成员变量。\n\nconst 对象const修饰对象称为常对象，对象被定义为常对象只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）。\nconst class object(para);class const object(para);const class *p = new class(para);class const *p = new class(para);\n\n无论哪种形式，只要定义为常对象就只能访问被 const 修饰的成员。\n","tags":["cpp"]},{"title":"【C/CPP】友元函数和友元类","url":"/2023/01/09/%E3%80%90C-CPP%E3%80%91%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB/","content":"友元（friend）可以使其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。\n友元函数友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数，在类中声明时要在前面加 friend 关键字。\n将非成员函数声明为友元函数class Student &#123;public:    friend void show(Student *pStu);\t// 将show()声明为友元函数private:    char *name_;&#125;;void show(Student *pStu)&#123;    cout &lt;&lt; pStu-&gt;name_ &lt;&lt; endl;&#125;int main()&#123;    Student std(&quot;Jone&quot;);    show(&amp;std);    return 0;&#125;\n\nshow() 是一个全局范围函的非成员函数，不属于任何类，声明为Student类的友元函数后即可访问类中的private成员。\n\n  注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。\n  成员函数调用时会隐式的增加 this 指针，才能访问到该对象的成员；而 show() 是非成员函数，没有 this 指针，所以无法访问成员，必须通过参数传递对象来访问。\n\n将其他类的成员函数声明为友元函数class Address;\t//提前声明要用到的类class Student &#123;public:    void show(Address *pAddr);private:    char *name_;&#125;;class Address &#123;public:    friend void Student::show(Address *pAddr);private:    char *address_;&#125;;void Student::show(Address *pAddr)&#123;    cout &lt;&lt; name_ &lt;&lt; pAddr-&gt;address_ &lt;&lt; endl;&#125;int main()&#123;    Student std(&quot;Jone&quot;);    Address addr(&quot;China&quot;)    std.show(&amp;addr);    return 0;&#125;\n\n在 Student 类中使用到了 Address 类，所以要提前进行声明。Student 类中的成员函数 show() 使用了 Address 的成员，所以在定义之前要先声明 Address 类。\n\n  类只有在正式声明后才能创建对象，在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量或引用变量。\n\n一个函数可以被对各类声明为友元函数，即可以访问多个类中的 private 成员。\n友元类将整个类声明为另一个类的朋友，就是友元类。友元类中的所有成员函数都是另一个类的友元函数。\nclass Address;\t//提前声明要用到的类class Student &#123;public:    void show(Address *pAddr);private:    char *name_;&#125;;class Address &#123;public:    friend class Student;\t// 将Student类声明为Address类的友元类private:    char *address_;&#125;;void Student::show(Address *pAddr)&#123;    cout &lt;&lt; name_ &lt;&lt; pAddr-&gt;address_ &lt;&lt; endl;&#125;\n\n需要注意：\n\n友元的关系是单向的而不是双向的。\n友元的关系不能传递。\n\n一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数。\n","tags":["cpp"]},{"title":"【C/CPP】继承与派生","url":"/2023/01/11/%E3%80%90C-CPP%E3%80%91%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","content":"继承是一个类从另一个类获取成员变量和成员函数的过程，被继承的类称为父类或基类，继承的类称为子类或派生类。\n使用继承的典型场景：\n\n创建的新类与现有类相似，只是多出了一些成员变量或成员函数。\n需要创建多个类，拥有很多相似的成员变量或成员函数。\n\nclass 派生类名 : [继承方式] 基类名 &#123;    派生类新增成员&#125;;\n\n继承方式继承方式限定了基类成员在派生类中的访问权限，包括 public、private和protected，缺省默认为 private。\n\npublic 继承方式\n基类的 public 成员在派生类为 public\n基类的 protected 成员在派生类为 protected\n基类的 private 成员在派生类中不能使用\n\n\nprotected 继承方式\n基类的 public 成员和 protected  成员在派生类为 protected \n基类的 private 成员在派生类中不能使用\n\n\nprivate 继承方式\n基类的 public 成员和 protected 成员在派生类为 private 属性\n基类的 private 成员在派生类中不能使用\n\n\n\n首先，基类成员在派生类中的访问权限不会超过继承方式指定的权限。其次，基类的 private 成员在派生类中始终无法访问。\n\n  注意：基类的 private 成员只是在派生类中不可见，并不是不能被继承。实际基类的 private 成员会占用派生类对象的内存。\n  使用 private 和 protected 继承方式会改变访问权限，导致继承关系复杂，实际开发中一般使用public。\n\n使用 using 关键字可以修改基类成员在派生类中的访问权限，只能修改基类中 public 和 protected 成员的访问权限。\nclass People &#123;public:    void show();protected:    char *m_name;    int m_age;&#125;;class Student : public People &#123;public:    using People::m_name;  //将protected改为public    using People::m_age;   //将protected改为public    float m_score;private:    using People::show;  //将public改为private&#125;;\n\n如果派生类成员和基类成员重名，则只会访问到派生类新增的成员，基类成员函数和派生类成员函数不构成重载，即使参数不同。\n构造函数和析构函数基类的成员函数可以被继承，但是构造函数不能被继承。需要在派生类中的构造函数调用基类的构造函数，来初始化基类的成员变量。\n基类构造函数不会被继承，不能当作普通的成员函数调用，需要放在参数初始化列表中。基类构造函数无论在参数初始化列表什么位置，派生类函数总是先调用基类构造函数再执行其他代码。\n派生类构造函数只能调用直接基类的构造函数，不能调用间接基类的。\n机构函数也不能被继承，但再派生类的析构函数中不需要显示地调用基类的析构函数。在销毁派生类对象时，析构函数的执行顺序与继承顺序相反，先执行派生类析构函数，再执行基类析构函数。\n","tags":["cpp"]},{"title":"快速入口","url":"/2023/01/11/%E5%BF%AB%E9%80%9F%E5%85%A5%E5%8F%A3/","content":":rocket:语言基础篇C&#x2F;CPP1.1 类与对象\n\nstatic 静态成员变量和函数详解\n:fire:const 修饰符\n友元函数和友元类\n\n"},{"title":"【C/CPP】虚继承详解","url":"/2023/01/12/%E3%80%90C-CPP%E3%80%91%E8%99%9A%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/","content":"","tags":["cpp"]}]