[{"title":"Hexo使用方法","url":"/2023/01/07/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\nCreate a new article$ hexo new [layout] &lt;title&gt;\n\n","tags":["博客"]},{"title":"【数据结构】基本数据结构类型","url":"/2023/01/08/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/","content":"复杂度分析大O时间复杂度表示法并不是具体表示代码执行的时间，而是表示代码执行时间随数据规模增长的变化趋势，也称为渐进时间复杂度，简称时间复杂度。\n分析时间复杂度方法：\n\n只关注循环执行次数最多的一段代码\n加法法则，总复杂度等于量级最大的那段代码的复杂度\n乘法法则，嵌套代码的复杂度等于嵌套内外代码复杂度的乘积\n\n几种常见的时间复杂度量级：\n\n非多项式量级：$O(2^n)$和$O(n!)$\n时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题，非多项式时间复杂度的算法是非常低效的算法。\nO(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。\n空间复杂度全称就是渐进空间复杂度（asymptotic space complexity)，表示算法的存储空间与数据规模之间的增长关系。\n数组数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。\n数组在内存空间的地址是连续的，支持根据下标随机访问，但在删除或添加元素时，需要移动后面的所有元素。\n线性表（Linear List）就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。\n\n非线性表，比如二叉树、堆、图等，数据之间并不是简单的前后关系。\n\n插入删除操作：如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。如果删除某个元素，我们可以先记录下已经删除的数据，当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。\nC++的vector是容器而不是数组，其底层实现是数组。而二维数组在内存的空间也是连续的。\nJava的二维数组每一行头节点的地址不是连续的：\n\n二分查找二分查找的前提是数组有序，如果数组有重复元素，可以通过控制边界找到最左侧或左右侧的目标元素。二分查找最主要的问题就是需要考虑清楚区间的定义。\nint binarySearch(vector&lt;int&gt; &amp;nums, int target) &#123;    int left = 0;    int right = nums.size() - 1;    while (left &lt;= right) &#123;        int mid = left + (right - left)/2;        if (nums[mid] &lt; target) &#123;            left = target + 1;        &#125;        else if (nums[mid] &gt; target) &#123;            right = target - 1;        &#125;        else &#123;            return mid;        &#125;    &#125;    return -1;&#125;\n\n相关题目：\n\n 35.搜索插入位置\n 34.在排序数组中查找元素的第一个和最后一个位置\n 69.x 的平方根\n 367.有效的完全平方数\n\n双指针双指针法（快慢指针）是通过一个快指针和慢指针在一个循环下完成两个循环的工作。双指针在数组和链表的操作中很常见，例如删除数组中的目标元素：\nclass Solution &#123;public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;        int slow = 0;        int fast = 0;        while (fast &lt; nums.size()) &#123;            if (val == nums[fast]) &#123;                fast++;            &#125;            else &#123;                nums[slow++] = nums[fast++];            &#125;        &#125;        return slow;    &#125;&#125;;\n\n相关题目：\n\n 26.删除排序数组中的重复项\n 283.移动零\n 844.比较含退格的字符串\n 977.有序数组的平方\n\n滑动窗口滑动窗口，就是不断调节子序列的起始位置和终止位置，从而得到我们想要的结果。实现滑动窗口，要确认以下三点：\n\n窗口内的元素是什么\n窗口的起始位置\n窗口的结束位置\n\n例如，获取数组和长度大于目标值的最小的子数组：\nclass Solution &#123;public:    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;        int len = nums.size()+1;        int sum = 0;        int start = 0;//起始位置        for (int i = 0; i &lt; nums.size(); ++i) &#123;            sum += nums[i];            while (sum &gt;= target) &#123;//窗口内的数组和要大于目标值                len = min(len, i - start + 1);                sum -= nums[start++];//缩小窗口大小            &#125;        &#125;        return len == nums.size()+1 ? 0 : len;    &#125;&#125;;\n\n相关题目：\n\n 904.水果成篮\n 76.最小覆盖子串\n\n链表链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作后继指针。\n\n第一个结点叫作头结点，用来记录链表的基地址。最后一个结点叫作尾结点，尾节点的下一个节点指向空地址NULL，表示这是链表中的最后一个结点。\n链表中插入和删除一个数据是非常快速的。只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。\n\n循环链表是一种特殊的单链表。循环链表的尾结点指针是指向链表的头结点。\n循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。\n双向链表每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点。\n链表使用技巧技巧一：理解指针或引用的含义\n将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。\n技巧二：警惕指针丢失和内存泄漏\n插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。\n删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。\n技巧三：利用哨兵简化实现难度\n针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。\n哨兵是解决“边界问题”的，不直接参与业务逻辑。引入哨兵结点，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。\n技巧四：重点留意边界条件处理\n检查链表代码是否正确的边界条件有这样几个：\n\n如果链表为空时，代码是否能正常工作？\n如果链表只包含一个结点时，代码是否能正常工作？\n如果链表只包含两个结点时，代码是否能正常工作？\n代码逻辑在处理头结点和尾结点的时候，是否能正常工作？\n\n在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！\n技巧五：举例画图，辅助思考\n链表相关题目：\n\n 单链表反转\n 链表中环的检测\n 两个有序的链表合并\n 删除链表倒数第 n 个结点\n 求链表的中间结点\n\n栈栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。\n特定的数据结构是对特定场景的抽象，数组或链表暴露了太多的操作接口，使用时就比较不可控，更容易出错。当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。\n栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。\n栈的应用场景\n栈在函数调用中的应用\n\n操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。\n\n栈在表达式求值中的应用\n\n编译器是通过两个栈来实现表达式求值。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。\n如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。\n例如，3+5*8-6 这个表达式的计算过程：\n\n\n栈在括号匹配中的应用\n\n借助栈来检查表达式中的括号是否匹配。假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。\n用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。\n当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。\n队列先进者先出，这就是典型的“队列”。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。队列跟栈一样，也是一种操作受限的线性表数据结构。\n队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。\n写好队列的关键是确定好队空和队满的判断条件。队列为空的判断条件是 head &#x3D;&#x3D; tail；队列满的判断条件是 (tail+1)%n &#x3D; head。\n\nclass MyCircularQueue &#123;public:    MyCircularQueue(int k) : capacity(k+1), head(0), tail(0) &#123;        items = vector&lt;int&gt;(k+1);    &#125;        bool enQueue(int value) &#123;        if (isFull()) &#123;            return false;        &#125;        items[tail] = value;        tail = (tail+1) % capacity;        return true;    &#125;        bool deQueue() &#123;        if (isEmpty()) &#123;            return false;        &#125;        head = (head+1) % capacity;        return true;    &#125;        int Front() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        return items[head];    &#125;        int Rear() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        return items[(tail-1+capacity)%capacity];    &#125;        bool isEmpty() &#123;        return head == tail;    &#125;        bool isFull() &#123;        return head == (tail+1) % capacity;    &#125;private:    vector&lt;int&gt; items;    int capacity;    int head;    int tail;&#125;;\n\n阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。\n基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。\n\n线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。\n","tags":["数据结构"]},{"title":"【C/CPP】static静态成员变量和函数详解","url":"/2023/01/08/%E3%80%90C-CPP%E3%80%91%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/","content":"静态成员变量对象的内存中包含了成员变量，不同对象占用不同内存，使得不同对象的成员变量相互独立。如果希望多个对象之间共享数据，典型使用场景是计数，可以使用静态成员变量来实现多个对象共享数据的目标。\n静态成员变量是一种特殊的成员变量，被关键字static修饰。\nclass Student &#123;public:    Student();    ~Student();private:    static int total_;&#125;;\n\n这段代码声明了一个静态成员变量total_，用来统计学生人数。\nstatic成员变量属于类，不属于某个具体的对象，必须在类声明的外部初始化，具体形式为：\nint Student::total_ = 0;\n\n\n  注意：static成员变量的内存既不是在声明类分配，也不是创建对象分配，而是在类外初始化时分配。没有在类外初始化的static成员变量无法使用。\n  static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。\n\n总结：\n\n一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。\nstatic 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。\n静态成员变量必须初始化，而且只能在类体外进行。初始化不赋值会被默认初始化为0。\n静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。\n\n\n  全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。\n\n普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。\n静态成员函数编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。\n静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。\n静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。\n静态成员函数与普通成员函数的区别：\n\n普通成员函数有 this 指针，可以访问类中的任意成员；\n静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。\n\n和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用。\n","tags":["cpp"]},{"title":"【C/CPP】const修饰符","url":"/2023/01/09/%E3%80%90C-CPP%E3%80%91const%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"如果不希望某些数据被修改，可以使用const关键字限定。\nconst 成员变量和成员函数const成员变量在初始化时只能通过构造函数的初始化列表。\nconst成员函数可以使用类中的所有成员变量，但是不能修改其值，主要是为了保护数据设置。通常将get函数设置成常成员函数。\n常成员函数在声明和定义的时候需要在函数头部后面加上const关键字。\nclass Student &#123;public:    char *getName() const;private:    char *name_;&#125;;char* Student::getName() const &#123;    return name_;&#125;\n\n注意 const 的位置区分：\n\n函数开头的 const 修饰的是函数的返回值，表示返回值是const类型，不能被修改，例如const char* getName()。\n函数头部结尾的 const 表示常成员函数，只能读取成员变量的值，不能修改成员变量。\n\nconst 对象const修饰对象称为常对象，对象被定义为常对象只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）。\nconst class object(para);class const object(para);const class *p = new class(para);class const *p = new class(para);\n\n无论哪种形式，只要定义为常对象就只能访问被 const 修饰的成员。\n","tags":["cpp"]},{"title":"【C/CPP】友元函数和友元类","url":"/2023/01/09/%E3%80%90C-CPP%E3%80%91%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB/","content":"友元（friend）可以使其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。\n友元函数友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数，在类中声明时要在前面加 friend 关键字。\n将非成员函数声明为友元函数class Student &#123;public:    friend void show(Student *pStu);\t// 将show()声明为友元函数private:    char *name_;&#125;;void show(Student *pStu)&#123;    cout &lt;&lt; pStu-&gt;name_ &lt;&lt; endl;&#125;int main()&#123;    Student std(&quot;Jone&quot;);    show(&amp;std);    return 0;&#125;\n\nshow() 是一个全局范围函的非成员函数，不属于任何类，声明为Student类的友元函数后即可访问类中的private成员。\n\n  注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。\n  成员函数调用时会隐式的增加 this 指针，才能访问到该对象的成员；而 show() 是非成员函数，没有 this 指针，所以无法访问成员，必须通过参数传递对象来访问。\n\n将其他类的成员函数声明为友元函数class Address;\t//提前声明要用到的类class Student &#123;public:    void show(Address *pAddr);private:    char *name_;&#125;;class Address &#123;public:    friend void Student::show(Address *pAddr);private:    char *address_;&#125;;void Student::show(Address *pAddr)&#123;    cout &lt;&lt; name_ &lt;&lt; pAddr-&gt;address_ &lt;&lt; endl;&#125;int main()&#123;    Student std(&quot;Jone&quot;);    Address addr(&quot;China&quot;)    std.show(&amp;addr);    return 0;&#125;\n\n在 Student 类中使用到了 Address 类，所以要提前进行声明。Student 类中的成员函数 show() 使用了 Address 的成员，所以在定义之前要先声明 Address 类。\n\n  类只有在正式声明后才能创建对象，在对一个类作了提前声明后，可以用该类的名字去定义指向该类型对象的指针变量或引用变量。\n\n一个函数可以被对各类声明为友元函数，即可以访问多个类中的 private 成员。\n友元类将整个类声明为另一个类的朋友，就是友元类。友元类中的所有成员函数都是另一个类的友元函数。\nclass Address;\t//提前声明要用到的类class Student &#123;public:    void show(Address *pAddr);private:    char *name_;&#125;;class Address &#123;public:    friend class Student;\t// 将Student类声明为Address类的友元类private:    char *address_;&#125;;void Student::show(Address *pAddr)&#123;    cout &lt;&lt; name_ &lt;&lt; pAddr-&gt;address_ &lt;&lt; endl;&#125;\n\n需要注意：\n\n友元的关系是单向的而不是双向的。\n友元的关系不能传递。\n\n一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数。\n","tags":["cpp"]},{"title":"【C/CPP】继承与派生","url":"/2023/01/11/%E3%80%90C-CPP%E3%80%91%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/","content":"继承是一个类从另一个类获取成员变量和成员函数的过程，被继承的类称为父类或基类，继承的类称为子类或派生类。\n使用继承的典型场景：\n\n创建的新类与现有类相似，只是多出了一些成员变量或成员函数。\n需要创建多个类，拥有很多相似的成员变量或成员函数。\n\nclass 派生类名 : [继承方式] 基类名 &#123;    派生类新增成员&#125;;\n\n继承方式继承方式限定了基类成员在派生类中的访问权限，包括 public、private和protected，缺省默认为 private。\n\npublic 继承方式\n基类的 public 成员在派生类为 public\n基类的 protected 成员在派生类为 protected\n基类的 private 成员在派生类中不能使用\n\n\nprotected 继承方式\n基类的 public 成员和 protected  成员在派生类为 protected \n基类的 private 成员在派生类中不能使用\n\n\nprivate 继承方式\n基类的 public 成员和 protected 成员在派生类为 private 属性\n基类的 private 成员在派生类中不能使用\n\n\n\n首先，基类成员在派生类中的访问权限不会超过继承方式指定的权限。其次，基类的 private 成员在派生类中始终无法访问。\n\n  注意：基类的 private 成员只是在派生类中不可见，并不是不能被继承。实际基类的 private 成员会占用派生类对象的内存。\n  使用 private 和 protected 继承方式会改变访问权限，导致继承关系复杂，实际开发中一般使用public。\n\n使用 using 关键字可以修改基类成员在派生类中的访问权限，只能修改基类中 public 和 protected 成员的访问权限。\nclass People &#123;public:    void show();protected:    char *m_name;    int m_age;&#125;;class Student : public People &#123;public:    using People::m_name;  //将protected改为public    using People::m_age;   //将protected改为public    float m_score;private:    using People::show;  //将public改为private&#125;;\n\n如果派生类成员和基类成员重名，则只会访问到派生类新增的成员，基类成员函数和派生类成员函数不构成重载，即使参数不同。\n构造函数和析构函数基类的成员函数可以被继承，但是构造函数不能被继承。需要在派生类中的构造函数调用基类的构造函数，来初始化基类的成员变量。\n基类构造函数不会被继承，不能当作普通的成员函数调用，需要放在参数初始化列表中。基类构造函数无论在参数初始化列表什么位置，派生类函数总是先调用基类构造函数再执行其他代码。\n派生类构造函数只能调用直接基类的构造函数，不能调用间接基类的。\n析构函数也不能被继承，但再派生类的析构函数中不需要显示地调用基类的析构函数。在销毁派生类对象时，析构函数的执行顺序与继承顺序相反，先执行派生类析构函数，再执行基类析构函数。\n向上转型类也是一种数据类型，也可以发生数据类型转换，不过这种转换只在基类和派生类直接才有意义，这能将派生类赋值给基类，称为向上转型。将基类赋值给派生类称为向下转型。\n将派生类赋值给基类，只会将基类存在的成员变量赋值，舍弃掉派生类新增的成员。\n通过基类指针访问派生类成员：\n\n访问成员变量，指针指向哪个对象就使用哪个对象的数据。\n访问成员函数，指针属于哪个类的类型就使用哪个类的函数。\n\n基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。\n","tags":["cpp"]},{"title":"快速入口","url":"/2023/01/11/%E5%BF%AB%E9%80%9F%E5%85%A5%E5%8F%A3/","content":"一、语言基础篇1.1 类与对象\n\nstatic 静态成员变量和函数详解\nconst 修饰符\n友元函数和友元类\n继承与派生\n\n二、数据结构篇2.1 基本数据结构\n"},{"title":"【数据结构】有序集合跳表","url":"/2023/01/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E8%B7%B3%E8%A1%A8/","content":"二分查找依赖数组随机访问的特性，如果对链表进行改造，也可以支持类似二分的查找算法，这种数据结构叫做跳表（Skip list）。\nRedis中的有序集合（Sorted Set）使用跳表来实现，可以支持快速插入、删除、查找操作，实现简单。\n\n普通链表在查找某个数据的时候，只能从头到尾遍历链表，查询效率很低。为了提高查询效率，我们将每两个节点提取一个节点到上一级，将提取出的一级叫做索引层。\n在查询时可以先在索引层遍历，依次下降到原始链表，这样查询过程需要遍历的节点减少了。\n这种链表加多级索引的结构，就是跳表。\n对于长度为 n 的链表，第一级索引的节点个数大约是 n&#x2F;2，第二级索引的节点个数大约是 n&#x2F;4，依次类推，第 k 级索引的节点个数为 n&#x2F;(2^k)。\n整个跳表的高度为 log2n，每一层需要遍历的节点有三个，因此跳表查询的时间复杂度为 O(logn)。\n跳表在构建索引时，需要额外再申请 n 个节点的存储空间。在实际软件开发中，原始链表可能存储的是很大的对象，而索引节点只需要存储关键值和几个指针，并不需要存储对象。所以当对象比索引节点大很多时，索引占用的空间可以忽略。\n高效的动态插入删除为了保证原始链表中数据的有序性，插入动作需要先找到插入位置，查找节点的时间复杂度为 O(logn)，因此插入节点的时间复杂度也是 O(logn)。\n删除节点时，要删除原始链表中的结点，还要删除索引中的。\n索引的动态更新当我们不停往条表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。\n作为一种动态数据结构，需要维护索引与原始链表大小之间的平衡，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。\n跳表是通过随机函数来维护索引大小。插入节点后，通过随机函数生成值 k，那么插入原始链表节点的同时，再第一级到第 k 级索引中同时添加该节点。\n","tags":["数据结构"]},{"title":"【C/CPP】typeid运算符获取类型信息","url":"/2023/01/15/%E3%80%90C-CPP%E3%80%91typeid%E8%BF%90%E7%AE%97%E7%AC%A6%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/","content":"typeid 运算符用来获取一个表达式的类型信息。类型信息描述了数据的属性：\n\n基本类型数据的类型信息主要是数据的类型。\n类的数据类型信息是指所属的类、包含的成员和所在的继承关系等。\n\n类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。\ntypeid 的操作对象既可以是表达式，也可以是数据类型。typeid 会把获取的类型信息保存在type_info类型的对象中，并返回该对象的常引用，通过成员函数来获取具体类型信息。\ntypeid 通常用来判断两个类型是否相同。使用 typeid 比较类型时，即使基类指针指向派生类，基类指针的类型不会改变。\ntype_info声明在 typeinfo头文件中。\n","tags":["cpp"]},{"title":"【C/CPP】多态与虚函数","url":"/2023/01/15/%E3%80%90C-CPP%E3%80%91%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0/","content":"通过基类指针只能访问到派生类的成员变量，但不能访问派生类的成员函数。可以通过虚函数让基类指针访问派生类的成员函数。\n使用虚函数需要在函数声明前增加 virtual 关键字。\nclass People&#123;public:    virtual void display();  //声明为虚函数&#125;;class Teacher: public People&#123;public:    virtual void display();  //声明为虚函数&#125;;\n\n将成员变量声明为虚函数，基类指针指向基类对象时使用基类成员，指向派生类对象时就使用派生类的成员。\n基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。\n使用虚函数时需要注意：\n\n只需在虚函数声明处加上 virtual 关键字，函数定义处可加可不加。\n只在基类函数声明为虚函数，这样所有派生类中具有遮蔽关系的同名函数都自动生成为虚函数。\n基类定义了虚函数，如果派生类没有函数遮蔽此函数，则使用基类的虚函数。\n只有派生类的虚函数和基类的虚函数函数原型相同才能构成多态。\n构造函数不能是虚函数，析构函数可以声明为虚函数。\n\n构成多态的条件封装、继承和多态时面向对象的三大特性，多态是指通过基类的指针可以访问基类的成员，也可以访问派生类的成员。\n构成多态的条件：\n\n必须存在继承关系。\n继承关系必须有同名虚函数，并且函数原型要相同。\n存在基类的指针，通过该指针调用虚函数。\n\n声明虚函数，首先看成员函数所在类是否会称为基类，其次看成员函数在类的继承后是否可能被更改功能，如果是则一般将它声明为虚函数。\n纯虚函数和抽象类纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾增加=0，表明此函数为纯虚函数。\nvirtual 返回值类型 函数名(函数参数) = 0;\n\n包含纯虚函数的类称为抽象类（Abstract Class）。抽象类无法创建对象，纯虚函数没有函数体，无法调用，也无法为其分配内存空间。\n抽象类作为基类，派生类实现纯虚函数后才能被实例化。\n\n纯虚函数可以使类成为抽象基类，但是抽象基类中还可以包含其它的成员函数（虚函数或普通函数）和成员变量。\n只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。\n\n","tags":["cpp"]},{"title":"【数据结构】散列表","url":"/2023/01/15/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%95%A3%E5%88%97%E8%A1%A8/","content":"散列表（Hash Table）通常称为哈希表，根据数组支持下标随机访问数据的特性，通过散列函数将元素的**键(key)**映射为下标，然后将数据存储在数组中对应下标的位置。\n散列函数散列函数可以定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。\n散列函数设计的基本要求：\n\n散列函数计算得到的散列值是一个非负整数。\n如果 key1 &#x3D;&#x3D; key2，那 hash(key1) &#x3D;&#x3D; hash(key2)。\n如果 key1 !&#x3D; key2，那 hash(key1) !&#x3D; hash(key2)。\n\n散列冲突散列函数要求中，键值不同但散列函数转换生成的索引值相同，称为散列冲突。散列冲突的解决方法有两类，开放寻址法和链表法。\n开放寻址法开放寻址法的核心思想是，如果出现散列冲突，就重新探测一个空闲的位置插入元素。\n线性探测（Linear Probing）是插入数据时，如果散列之后的存储位置已经被占用，就依次往后查找空闲位置。在查找数据时，如果遍历到空闲位置还没有找到数据，就说明要查找的数据不在散列表中。\n通过线性探测法设计的散列函数，在删除数据时需要注意，不能直接将要删除的元素置空。如果直接置空的话会产生一个空闲位置，影响其他元素的查询和删除。可以将要删除的元素标记下来，当线性探测查找时，遇到该标记会继续向下探测。\n二次探测（Quadratic Probing）跟线性探测类似，线性探测每次探测的步长是1，二次探测的步长是原来的二次方，即探测的下标序列为 hash(key)+0，hash(key)+1^2，hash(key)+2^2……\n双重散列（Double hashing）是使用一组散列函数依次进行计算，如果得到的存储位置被占用，就继续使用下一个散列函数，知道找到空闲的位置。\n使用线性探测法，随着空闲位置的减少，散列冲突的概率会大大提高，查找效率会变低。使用装载因子（Load Factor）来表示空位的多少，装载因子的计算公式是：\n装载因子 = 填入元素个数 / 散列表的长度\n\n链表法链表法是一种更加常用的散列冲突解决办法。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。\n\n\n插入数据时只需要通过散列函数计算出对应的散列槽位，将其插入对应的链表中即可，插入的时间复杂度是O(1)。\n散列表设计散列函数设计散列函数的设计不能太复杂。过于复杂的散列函数会消耗计算时间。其次，散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突。\n装载因子过大装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。\n动态扩容会重新申请内存并将原来的散列表搬移到新的散列表中，这就会导致极个别的插入操作耗时较多。我们可以将扩容操作穿插在插入操作的过程中，当装载因子达到阈值后，只申请内存并将新数据插入在新的散列表中，之后每插入一个数据，就将新数据插入新散列表中，然后从老的散列表拿出一个数据放到新散列表。这期间的查询操作，先从新表中查找，然后再到旧表中查找。\n散列冲突解决方法开放寻址法数据都存储在数组中，查询速度较快，序列化简单。但在删除数据时比较麻烦，而且散列冲突的代价更高。当数据量较小，装载因子小的时候适合用开放寻址法，Java 中的 ThreadLocalMap 使用了开放寻址法。\n\n  开放寻址法只能适用于装载因子小于1的情况，接近1时会有大量的散列冲突。\n\n链表法内存利用率较高，只要散列函数的值随即均匀，即便装载因子高，也只是链表的长度变长，查找效率比顺序查找要快。\n","tags":["数据结构"]}]